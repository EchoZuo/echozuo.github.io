<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Google GCP搭建专属免费VPS]]></title>
    <url>%2F2019%2F07%2F14%2F%E4%BD%BF%E7%94%A8Google%20GCP%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E5%85%8D%E8%B4%B9VPS%2F</url>
    <content type="text"><![CDATA[郑重申明：本文用于记录、总结、分享云服务器自行搭建VPS的过程及方法。如将其作用于违反法律法规的事情，与本人无关。请遵守当地法律法规。简介感谢谷歌提供的GCP服务（Google Cloud Platform，谷歌云平台服务），首次注册激活GCP，你会获享12个月试用期和$300 赠金，是不是免费？ 请注意：教程很详细，图很多！ 首先你需要 谷歌账号以及能访问谷歌站点的一台电脑（首先你要能登录谷歌GCP） 外币卡（VISA、Mastercard、AE）（实测招行VISA全币种卡可以） 开始搭建1. 登录 Google Cloud Platform 激活账户填写相关信息 右上角点击language修改语言为中文简体（如果你的英文很棒那么可以不用改） 点击右上角免费试用 国家/地区可以选择香港，点击继续，登录谷歌账户 填写个人信息和信用卡信息 账户类型记得选个人 信用卡必须填写。填写之后点击开始免费使用。 谷歌声称“我们要求您提供信用卡信息是为了确认您不是机器人。除非您手动升级为付费帐号，否则我们不会向您收费。”具体信息可以参考：https://www.youtube.com/watch?v=kJHKsOywfxE 激活成功之后你会看到如下界面，并且会有提示$300美金和12个月免费试用期。 2. 创建VM虚拟机实例 左侧导航栏选择 计算 —&gt; Computer Engine —&gt; VM实例 等待 Compute Engine 启用完成后，点击创建，开始自定义实例配置 - 填写 名称 - 选择 区域 及 地区（日本站点距离近，响应速度快） - 调整一下 内核 及 内存，选择最低共享配置即可满足 - 更改 启动磁盘 为 Ubuntu 18.04 LTS - 防火墙勾选 允许 HTTP 流量 允许 HTTPS 流量 - 点击 创建，创建完成如下图。 3. 设置防火墙规则 左侧菜单栏 —&gt; 网络 —&gt; VPC网络 —&gt; 防火墙规则 点击创建防火墙规则 - 名称 按规则自定义 - 目标 选择 网络中的所有实例 - 来源ip地址范围 0.0.0.0/0 - 协议和端口 勾选 UDP 填写 500,4500，勾选 其他协议 填写 esp - 点击 创建，创建成功，如下图 4. 配置VPC网络 - 左侧菜单栏 ---&gt; 网络 ---&gt; VPC网络 ---&gt; default - 点击修改 - 子网创建模式 选择 自动 - 动态路由模式 选择 全局 - 点击保存即可5. 设置 负载平衡 左侧菜单栏 —&gt; 网络 —&gt; 负载平衡 点击创建负载平衡 直接点击继续 - 名称 按规则自定义填写 - 选择 区域 - 选择第一步所创建的VM实例 - 点击前端配置 - 名称 按规则自定义填写 - 端口 填写500-4500 - 点击 完成 - 点击 创建，创建完成如下 6. 登录服务器 导航菜单 → Compute Engine → VM实例 点击 SSH，会进入到远程终端页面 7. 开始部署服务 执行以下命令1sudo apt-get update &amp;&amp; apt-get dist-upgrade 控制台输出1234567891011121314151617181920212223242526272829303132333435363738The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.zuoqianheng@instance-1:~$ sudo apt-get update &amp;&amp; apt-get dist-upgradeHit:1 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic InReleaseGet:2 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB] Get:3 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB] Get:4 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [8570 kB] Get:5 http://archive.canonical.com/ubuntu bionic InRelease [10.2 kB] Get:6 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB] Get:7 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic/universe Translation-en [4941 kB]Get:8 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [151 kB] Get:9 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic/multiverse Translation-en [108 kB] Get:10 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [682 kB] Get:11 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/main Translation-en [251 kB] Get:12 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [970 kB] Get:13 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/universe Translation-en [293 kB] Get:14 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [6640 B] Get:15 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-updates/multiverse Translation-en [3556 B]Get:16 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2512 B] Get:17 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-backports/main Translation-en [1644 B] Get:18 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [3736 B] Get:19 http://asia-northeast1.gce.archive.ubuntu.com/ubuntu bionic-backports/universe Translation-en [1696 B]Get:20 http://archive.canonical.com/ubuntu bionic/partner amd64 Packages [2320 B] Get:21 http://archive.canonical.com/ubuntu bionic/partner Translation-en [1276 B]Get:22 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [450 kB]Get:23 http://security.ubuntu.com/ubuntu bionic-security/main Translation-en [156 kB]Get:24 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [570 kB]Get:25 http://security.ubuntu.com/ubuntu bionic-security/universe Translation-en [185 kB]Get:26 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [4008 B]Get:27 http://security.ubuntu.com/ubuntu bionic-security/multiverse Translation-en [2060 B]Fetched 17.6 MB in 4s (4193 kB/s) Reading package lists... DoneE: Could not open lock file /var/lib/dpkg/lock-frontend - open (13: Permission denied)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), are you root?zuoqianheng@instance-1:~$ 命令行一步部署VPN服务 1234wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo \VPN_IPSEC_PSK=&apos;预分享密钥&apos; \VPN_USER=&apos;用户名&apos; \VPN_PASSWORD=&apos;密码&apos; sh vpnsetup.sh 记得修改命令中的个人信息部分。 一个安全的 IPsec PSK 应该至少包含 20 个随机字符。需要等待大概5-10分钟后，控制台输出 详细部署VPN服务教程可参考：IPsec VPN 服务器一键安装脚本 看到上图，我们的的VPN就算搭建成功了123456789101112================================================IPsec VPN server is now ready for use!Connect to your new VPN with these details:Server IP: 34.*******IPsec PSK: ********************Username: ******************Password: ***************Write these down. You&apos;ll need them to connect!Important notes: https://git.io/vpnnotesSetup VPN clients: https://git.io/vpnclients================================================zuoqianheng@instance-1:~$ 8. 如何连接？ Mac、iOS设置可以直接在网络设置中找到VPN，添加对应的服务器、用户名、密码等数据即可访问。Windows 用户可以使用免费的 Shrew Soft 客户端。可以参考这里：配置 IPsec/XAuth VPN 客户端 如果无法连接,请首先检查是否输入了正确的 VPN 登录凭证。 Info Github: https://github.com/EchoZuo jianshu: https://www.jianshu.com/u/3390ce71084e CSDN: https://blog.csdn.net/zuoqianheng Email: zuoqianheng@foxmail.com Telegram: @echozuo 参考链接 Google Cloud 【BIG东东】关于谷歌云的结算和防火墙规则端口开通 如何利用谷歌云搭建12个月免费VPN教程，google2018免费VPN送300美金 Google Cloud Platform 搭建個人VPN 10分钟教你用 Google Cloud Platform 搭建自己的VPN https://github.com/hwdsl2]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>谷歌</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac更新系统后 删除文件后可用空间还变少了？]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8E%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%98%E5%8F%98%E5%B0%91%E4%BA%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[写在最前面：此教程仅针对装有macOS 10.15 Catalina Beta系统的用户，且开启了TimeMachine的用户有效。如果不满足以上任何一个条件的用户就可以关闭网页了。 WWDC19之后升级给自己闲置的MacBookPro2015款升级了10.15beta系统，开开心心升级之后，却遇到了一个十分诡异的问题。256GB的电脑硬盘空间有些吃紧（移动开发工程师，电脑和2T的移动硬盘都已经塞的满满的）本来就是闲置的Mac，为了再装一个beta版Xcode，就删了很多暂时闲置不用的软件和资料，不过令我十分不解和诡异的是，原本装完系统后，有17G左右剩余，竟然越删空间越小（如下图），甚至当我删除了正式版本Xcode和一堆文件（近20GB）之后，Mac存储空间竟然只剩下14GB左右（忘记截图）。 我电脑的剩余容量究竟去哪里了呢？100多GB的其他容量到底是何物？按照以往的惯例，我用CleanMyMac、daisydisk等一些列清理软件进行检测清理。对的，你没猜错，于事无补，没有任何效果。无数次的关机重启、按住shift进入安全模式，依旧于事无补。随后查了了下系统信息以及磁盘信息。竟然发现…有两个Macintosh HD。 不敢轻易删除某一个Macintosh HD，在我快要放弃想要备份数据重装系统的时候，意外的谷歌搜到中关村在线的一篇文稿（是的，中关村在线的文稿，谷歌搜出，百度没有）。随后完美解决了问题。原因如下：macOS 10.15 Catalina Beta再次改了系统分区系统（貌似WWDC19的keynote有看到过），当然也有可能是系统bug，在开启了TimeMachine自动备份的情况下，所有被删除的文件都会以文件快照的形式存储在隐藏分区内，也就是所谓的hidden space，并且在文件系统中会将这部分空间显示为可清除空间，这些文件快照只有在系统可用空间不足的情况下才会自动删除，我们只需要想办法将这些文件快照强制删除即可。解决方案：下面就来搬运一下中关村在线上一位叫做“韩立人”分享的办法。打开“终端”输入如下代码1echozuo-mbp:~ EchoZuo$ sudo tmutil listlocalsnapshots / 你可以看到1234echozuo-mbp:~ EchoZuo$ sudo tmutil listlocalsnapshots /Password:com.apple.TimeMachine.2019-06-06-212733.localcom.apple.TimeMachine.2019-06-07-203209.local 接下来尝试删除第一个快照文件，后面的文件名需要根据自己的显示来改变1echozuo-mbp:~ EchoZuo$ tmutil deletelocalsnapshots 2017-12-18-093234 如果出现如下显示，你会发现磁盘空间已经空出来了不少1Deleted local snapshot &apos;2017-12-18-093234&apos; 可以删除其他所有快照之后，可以再次输入如下命令检测1echozuo-mbp:~ EchoZuo$ sudo tmutil listlocalsnapshots / 查看存储空间信息，你会发现所有缺失的空间会全部恢复回来 最后特别感谢中关村在线论坛的的帮助。参考：http://nb.zol.com.cn/671/6715453.html 笔者是一位iOS开发工程师，更是一个果粉，有什么Apple产品使用相关的问题也可以给我留言咨询，帮助大家解答。期待您的关注~]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
        <tag>存储</tag>
        <tag>存储空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode10、Xcode 11 beta 运行libstdc++报错解决方案]]></title>
    <url>%2F2019%2F06%2F06%2Flibstdc-%E6%8A%A5%E9%94%99-190606%2F</url>
    <content type="text"><![CDATA[最新处理方案已经更新，可直接跳过到文章结尾查看处理方案！ 新增脚本处理方案。 报错内容library not found for -lstdc++.6.0.9错误截图 这个错误原因是因为iOS12.0之后去掉了lstdc++.6.0.9.tbd动态库，如下图搜索便知： iOS12.0中全部采用libc++代替lstdc++的动态库（如下图），具体原因可以参考：http://www.cnblogs.com/wellbye/archive/2013/04/25/3039203.html 因为beta版本Xcode是无法打包上传appstore，所以肯定还是需要Xcode10+Xcode11并行使用，而且现在部分第三方SDK依旧要依赖于lstdc++.6.0.9.tbd动态库，如果对代码进行改动或者修改Xcode的配置，可能会造成其他问题，例如在Xcode10上再次运行的时候可能会出现报错等等。所以最简单解决该问题的方法就是从Xcode10中找到动态库lstdc++.6.0.9.tbd文件copy到Xcode 11 beta下就可以完美解决问题。或者用古老的办法将iOS13的DeviceSupport文件copy到Xcode11.0下也可以完美解决Xcode11.0运行iOS13的问题。 解决方案需要将文件复制到下述四个路径下，才能保证模拟器和真机均好用Xcode10下：1234/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ Xcode11-beta下：主要是第一条```的路径发生了变更，Xcode10中是```../Developer/Library/..```，而Xcode11中是```.../Library/Developer/...```12345```/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib /Applications/Xcode-beta.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib//Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib//Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/为了方便大家，在此提供lstdc++动态库文件下载和DeviceSupport下载 链接：libstdc DeviceSupport(8.0-13.0beta) 所有版本 DeviceSupport：iOS 7.0 - iOS 12 beta1 所有版本 iPhoneOS13.0.sdk 新增脚本处理方案：点击下载12345// install.sh：Xcode10.2.1及其以下// install-xcode-beta11.sh：Xcode11betaMacBook-Pro:~ EchoZuo$ cd /Users/EchoZuo/Desktop/xcode\ libstdc MacBook-Pro:xcode libstdc EchoZuo$ ./install-xcode-beta11.shMacBook-Pro:xcode libstdc EchoZuo$ ./install.sh Info Github: https://github.com/EchoZuo jianshu: https://www.jianshu.com/u/3390ce71084e CSDN: https://blog.csdn.net/zuoqianheng Email: zuoqianheng@foxmail.com Telegram: @echozuo]]></content>
      <categories>
        <category>iOS Dev</category>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>libstdc++</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac & iPhone 日历中加入国内法定假期（共享）2019 最新]]></title>
    <url>%2F2019%2F01%2F02%2FMac%26iPhone%E6%97%A5%E5%8E%86%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BD%E5%86%85%E6%B3%95%E5%AE%9A%E5%81%87%E6%9C%9F%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%892019%20%E6%9C%80%E6%96%B0%2F</url>
    <content type="text"><![CDATA[无数用户钟爱 Apple 自带「提醒事项」和「日历」应用，用来管理日常日程确实很方便，尤其是对于使用苹果三件套的用户来说多设备之间无缝衔接同步更为便利。但也因其功能限制，招人吐槽。例如无法查看国内节假日（老版本系统），无法查看国内法定假期补班调休等。 ##### 那么，如何在Mac OSX 或者iOS系统自带日历软件中加入中国节假日以及法定假期补班调休日历？ 两种方式1. 订阅制 优点：一次订阅，终身使用。（当前前提是不删除订阅并且提供方一直更新日历信息）。 缺点：无法编辑订阅日历，只读模式。2. 直接下载导入日历 优点：可以后期自行编辑下载的日历信息。 缺点：日历订阅方更新日历信息后，用户无法实时更新日历信息，需要再次下载日历导入。 订阅制还有一个缺点就是，日历订阅提供方可以修改日历加入更多广告！这点用户可能无法避免，但是可以选择订阅的日历免提醒！当然我提供日历订阅只是为了方便大家，并非为了打广告！哈哈！ 订阅或者导入日历方式订阅地址：webcal://p10-calendars.icloud.com/published/2/MTI3Njk0MTQxNzEyNzY5NFRvxM53AOH-Px17vHeUETlZdUggoyEt2KnFiIqHg40FkRXfcQJjYoa2dULRarI9z4UlbHxK-kLOohfiRVSSP7Q下载日历ics文件地址：http://p10-calendars.icloud.com/published/2/MTI3Njk0MTQxNzEyNzY5NFRvxM53AOH-Px17vHeUETlZdUggoyEt2KnFiIqHg40FkRXfcQJjYoa2dULRarI9z4UlbHxK-kLOohfiRVSSP7Q订阅制Mac OSX 复制上方订阅地址 打开Mac OSX 自带日历应用 点击左上角文件—新建日历订阅，将复制的订阅地址粘贴，点击订阅。 如下图，上面会有一些配置信息，可以做修改。例如可以选择自动刷新频率（意思就是如果日历有修改，你多久更新一次）；还有可以忽略日历提醒。（不懂的话可以@我帮大家说明）。 点击“好”之后即可订阅成功，在日历中即可看到刚才订阅的日历。 如果要取消订阅，在左边日历列表栏中选中订阅的日历，右键—取消订阅。也可修改配置或者将订阅地址URL拷贝共享给更多朋友。##### iOS 和Mac OSX不同的是，iOS系统日历软件中没有直接提供订阅日历的入口（或者我没找到，有谁找到了可以@我修改一下文章），所以这里借助备忘录实现订阅功能。 新建一备忘录，将订阅地址复制粘贴到备忘录中，点击右上角完成。然后点击订阅地址，会弹框“是否订阅日历“法定节假””，点击订阅，会提示“已添加日历“法定节假日””，然后点击显示日程即可查看订阅日历。 也可以直接复制订阅地址到Safari中直接打开（必须且Safari），同样多的操作步骤，即可订阅！ 如果使用Mac和iOS同步日历的用户，可以直接通过Mac订阅且位置选择iCloud，即可同步到订阅日历到iOS设备，也很便利。##### 直接下载导入日历Mac OSX 浏览器访问下载日历ics文件地址即可下载日历ics文件，双击导入。选择一个目录加入即可。 iOS 备忘录或者Safari打开下载日历ics文件地址链接 提示如下图，点击右上角“添加全部”即可导入日历，或者点击某一项日程，可以单独添加某一项日程到日历应用中。 ###### Notes 目前已更新支持2019国家法定假期。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac技巧</tag>
        <tag>Mac日历</tag>
        <tag>iPhone日历</tag>
        <tag>日历</tag>
        <tag>共享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS FaceID & TouchID]]></title>
    <url>%2F2017%2F11%2F09%2FiOS%20FaceID%26TouchID%2F</url>
    <content type="text"><![CDATA[iOS FaceID &amp; TouchIDAPI文档 System/LocalAuthenticationFaceID和TouchID本身基本逻辑很简单（当然需要置入一些安全相关的第三方SDK的情况下除外），先来介绍几个关键参数值和一些主意事项，然后直接贴代码就OKLAPolicyDeviceOwnerAuthenticationWithBiometrics 和 LAPolicyDeviceOwnerAuthentication LAPolicyDeviceOwnerAuthenticationWithBiometrics iOS 8.0+ 12345// 设备所有者使用生物识别方法进行认证。TouchID验证是必须的，如果TouchID不可用或者没有注册，则策略评估将会失败。如果TouchID是锁被锁定，则需要输入密码作为解锁TouchID的第一步。// TouchID对话框包括一个取消按钮，默认标题为“取消”，可以使用“localizedCancelTitle”属性去修改。有一个fallback按钮默认标题为“输入密码”，可以通过“localizedFallbackTitle”属性去修改。// fallback按钮最初是隐藏的，并且在首次touchID尝试失败之后显示。// 点击取消按钮或者输入密码按钮后会导致 evaluatePolicy: 方法调用失败，返回一个不同的错误代码。// 5次验证失败，生物识别将被锁定。之后，用户必须输入密码才可以解锁验证。 LAPolicyDeviceOwnerAuthentication iOS 9.0+ 12345// 设备所有者使用生物识别后者设备密码进行验证。// TouchID或者密码验证是必须的，如果TouchID可用，注册并且未被锁定，首先使用TouchID验证。否则直接要求输入设备密码。// 如果密码未被启用，则策略评估失败。// Touch ID身份验证对话框的行为与LAPolicyDeviceOwnerAuthenticationWithBiometrics使用的行为相似。当点击输入密码按钮的时候，切换验证方法，并允许用户输入设备密码。// 密码锁定会在6次失败尝试之后被锁定，并且逐步增加退避延迟。 iOS11新增属性 LABiometryType biometryType iOS 11.0+ 这里需要注意的是请仔细阅读 biometryType 属性的注释。中文意思为只有当canEvaluatePolicy:生物识别策略成功之后才会去设置这个属性的值。简单来说意思就是 biometryType 这个属性的值只有在你调用canEvaluatePolicy:方法之后并且返回是YES没有错误的情况下才会设置，才会有值。在调用 canEvaluatePolicy: 方法前，或者调用后但是有Error的情况下，该属性均无任何有意义的值，验证之后实际为空。 1234567891011121314151617typedef NS_ENUM(NSInteger, LABiometryType)&#123; /// The device does not support biometry. LABiometryNone, /// The device supports Touch ID. LABiometryTypeTouchID, /// The device supports Face ID. LABiometryTypeFaceID,&#125; NS_ENUM_AVAILABLE(NA, 11_0) __WATCHOS_UNAVAILABLE __TVOS_UNAVAILABLE;/// Indicates the type of the biometry supported by the device.////// @discussion This property is set only when canEvaluatePolicy succeeds for a biometric policy./// The default value is LABiometryNone.@property (nonatomic, readonly) LABiometryType biometryType NS_AVAILABLE(NA, 11_0) __WATCHOS_UNAVAILABLE __TVOS_UNAVAILABLE; 代码附上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 检测设备是否支持TouchID或者FaceID if (@available(iOS 8.0, *)) &#123; self.LAContent = [[LAContext alloc] init]; NSError *authError = nil; BOOL isCanEvaluatePolicy = [self.LAContent canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;authError]; if (authError) &#123; NSLog(@&quot;检测设备是否支持TouchID或者FaceID失败！\n error : == %@&quot;,authError.localizedDescription); [self showAlertView:[NSString stringWithFormat:@&quot;检测设备是否支持TouchID或者FaceID失败。\n errorCode : %ld\n errorMsg : %@&quot;,(long)authError.code, authError.localizedDescription]]; &#125; else &#123; if (isCanEvaluatePolicy) &#123; // 判断设备支持TouchID还是FaceID if (@available(iOS 11.0, *)) &#123; switch (self.LAContent.biometryType) &#123; case LABiometryNone: &#123; [self justSupportBiometricsType:0]; &#125; break; case LABiometryTypeTouchID: &#123; [self justSupportBiometricsType:1]; &#125; break; case LABiometryTypeFaceID: &#123; [self justSupportBiometricsType:2]; &#125; break; default: break; &#125; &#125; else &#123; // Fallback on earlier versions NSLog(@&quot;iOS 11之前不需要判断 biometryType&quot;); // 因为iPhoneX起始系统版本都已经是iOS11.0，所以iOS11.0系统版本下不需要再去判断是否支持faceID，直接走支持TouchID逻辑即可。 [self justSupportBiometricsType:1]; &#125; &#125; else &#123; [self justSupportBiometricsType:0]; &#125; &#125; &#125; else &#123; // Fallback on earlier versions [self justSupportBiometricsType:0]; &#125;&#125;#pragma mark -#pragma mark -------------------- private actions --------------------// 开始验证按钮点击事件- (IBAction)didClickBtnCheck:(id)sender &#123; NSString *myLocalizedReasonString = @&quot;验证&quot;; [self.LAContent evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:myLocalizedReasonString reply:^(BOOL success, NSError * _Nullable error) &#123; if (success) &#123; NSLog(@&quot;身份验证成功！&quot;); [self showAlertView:@&quot;验证成功&quot;]; &#125; else &#123; // 做特定的错误判断处理逻辑。 NSLog(@&quot;身份验证失败！ \nerrorCode : %ld, errorMsg : %@&quot;,(long)error.code, error.localizedDescription); // error 参考 LAError.h [self showAlertView:[NSString stringWithFormat:@&quot;身份验证失败！\nerrCode : %ld\nerrorMsg : %@&quot;,(long)error.code, error.localizedDescription]]; &#125; &#125;];&#125;#pragma mark -#pragma mark -------------------- common methods --------------------// 判断生物识别类型，更新UI- (void)justSupportBiometricsType:(NSInteger)biometryType&#123; switch (biometryType) &#123; case 0: &#123; NSLog(@&quot;该设备支持不支持FaceID和TouchID&quot;); self.lblMsg.text = @&quot;该设备支持不支持FaceID和TouchID&quot;; self.lblMsg.textColor = [UIColor redColor]; self.btnCheck.enabled = NO; &#125; break; case 1: &#123; NSLog(@&quot;该设备支持TouchID&quot;); self.lblMsg.text = @&quot;该设备支持Touch ID&quot;; [self.btnCheck setTitle:@&quot;点击开始验证Touch ID&quot; forState:UIControlStateNormal]; self.btnCheck.enabled = YES; &#125; break; case 2: &#123; NSLog(@&quot;该设备支持Face ID&quot;); self.lblMsg.text = @&quot;该设备支持Face ID&quot;; [self.btnCheck setTitle:@&quot;点击开始验证Face ID&quot; forState:UIControlStateNormal]; self.btnCheck.enabled = YES; &#125; break; default: break; &#125;&#125;// 弹框- (void)showAlertView:(NSString *)msg&#123; NSLog(@&quot;%@&quot;,msg); if (@available(iOS 8.0, *)) &#123; UIAlertAction *okAction = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleCancel handler:nil]; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil message:msg preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:okAction]; [self presentViewController:alertController animated:YES completion:nil]; &#125; else &#123; // Fallback on earlier versions UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:msg delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil]; [alertView show]; &#125;&#125; LAError1234567891011121314151617181920212223242526272829303132333435363738394041424344454647typedef NS_ENUM(NSInteger, LAError)&#123; //身份验证不成功，因为用户无法提供有效的凭据。 LAErrorAuthenticationFailed = kLAErrorAuthenticationFailed, //认证被用户取消(例如了取消按钮)。 LAErrorUserCancel = kLAErrorUserCancel, //认证被取消了,因为用户利用回退按钮(输入密码)。 LAErrorUserFallback = kLAErrorUserFallback, //身份验证被系统取消了(如另一个应用程序去前台)。 LAErrorSystemCancel = kLAErrorSystemCancel, //身份验证无法启动,因为设备没有设置密码。 LAErrorPasscodeNotSet = kLAErrorPasscodeNotSet, //身份验证无法启动,因为触摸ID不可用在设备上。 LAErrorTouchIDNotAvailable NS_ENUM_DEPRECATED(10_10, 10_13, 8_0, 11_0, &quot;use LAErrorBiometryNotAvailable&quot;) = kLAErrorTouchIDNotAvailable, //身份验证无法启动,因为没有登记的手指触摸ID。 LAErrorTouchIDNotEnrolled NS_ENUM_DEPRECATED(10_10, 10_13, 8_0, 11_0, &quot;use LAErrorBiometryNotEnrolled&quot;) = kLAErrorTouchIDNotEnrolled, //验证不成功,因为有太多的失败的触摸ID尝试和触///摸现在ID是锁着的。 //解锁TouchID必须要使用密码，例如调用LAPolicyDeviceOwnerAuthenti//cationWithBiometrics的时候密码是必要条件。 //身份验证不成功，因为有太多失败的触摸ID尝试和触摸ID现在被锁定。 LAErrorTouchIDLockout NS_ENUM_DEPRECATED(10_11, 10_13, 9_0, 11_0, &quot;use LAErrorBiometryLockout&quot;) __WATCHOS_DEPRECATED(3.0, 4.0, &quot;use LAErrorBiometryLockout&quot;) __TVOS_DEPRECATED(10.0, 11.0, &quot;use LAErrorBiometryLockout&quot;) = kLAErrorTouchIDLockout, //应用程序取消了身份验证（例如在进行身份验证时调用了无效）。 LAErrorAppCancel NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorAppCancel, //LAContext传递给这个调用之前已经失效。 LAErrorInvalidContext NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorInvalidContext, //身份验证无法启动,因为生物识别验证在当前这个设备上不可用。 LAErrorBiometryNotAvailable NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryNotAvailable, //身份验证无法启动，因为生物识别没有录入信息。 LAErrorBiometryNotEnrolled NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryNotEnrolled, //身份验证不成功，因为太多次的验证失败并且生物识别验证是锁定状态。此时，必须输入密码才能解锁。例如LAPolicyDeviceOwnerAuthenticationWithBiometrics时候将密码作为先决条件。 LAErrorBiometryLockout NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryLockout, //身份验证失败。因为这需要显示UI已禁止使用interactionNotAllowed属性。 据说是beta版本 LAErrorNotInteractive API_AVAILABLE(macos(10.10), ios(8.0), watchos(3.0), tvos(10.0)) = kLAErrorNotInteractive,&#125; NS_ENUM_AVAILABLE(10_10, 8_0) __WATCHOS_AVAILABLE(3.0) __TVOS_AVAILABLE(10.0); Info Github: https://github.com/EchoZuo jianshu: https://www.jianshu.com/u/3390ce71084e CSDN: https://blog.csdn.net/zuoqianheng Email: zuoqianheng@foxmail.com Telegram: @echozuo]]></content>
      <categories>
        <category>iOS Dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>FaceID</tag>
        <tag>TouchID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS11 Core NFC]]></title>
    <url>%2F2017%2F08%2F22%2FiOS11CoreNFC%2F</url>
    <content type="text"><![CDATA[About Core NFCCore NFC支持的读取数据类型： Core NFC框架特性/要求 目前支持NFC Tags（标签）的读取 不支持输出和格式设置 仅支持iphone 7 &amp; iphone 7plus，且iOS11系统 项目加入Core NFC框架使用的要求 （必须）支持iOS11，且只有iOS11和iphone7/plus机型才可以 （必须）像Apple pay或者Push Notification一样，需要添加一个entitlement （保修）在plist文件中添加Privacy - NFC Scan Usage Description。这里使用的描述信息会显示在读取界面中 集成Core NFC中的一些细节说明 设备读取标签是一个被动的过程，所以需要程序主动发起一个会话即为session去读取标签。与处理摄像头相关功能类似，所有的操作都必须建立在session基础之上 程序必须始终保持前台运行并且识别界面可视。如果至于后台session会自动终止，读取失败。 Tips：这里我做过一个测试，实际上当Core NCF读取标签界面出现后，无法下拉通知栏中心，也无法上滑出现控制中心，如果识别过程中，点击home第一次会取消识别，不会直接进入主屏幕。这样的设计应该是为了防止在识别过程中出现误操作等情况的发生 读取标签被限制的60秒之内。意思就是60秒内标签必须识别完成，否则session会自动终止。如果会话过期或者未经过验证，则你的程序需要重新去建立新的会话 Core NFC可以设置会话读取一个标签或者多个标签。在读取单个标签的时候，读取完成后，会话自动终止。如果读取多个标签，会话会一直持续直到程序主动终止会话或者60秒后。60秒是一个最大的节点 示例代码代码很简单！！！其实Core NFC目前放出的权限很少，只支持特定格式的NFC数据读取，不支持输出和格式设置，所以代码上很简单，可以说是傻瓜式的调用处理即可。我猜想可能是因为Apple为了保证Apple Pay的安全性，毕竟Apple Pay也是采用NFC完成支付。使用Core NFC @import CoreNFC 导入框架，这点没啥可说的 遵循 NFCNDEFReaderSessionDelegate 协议 创建 NFCNDEFReaderSession 实例 开启 NFCNDEFReaderSession 以及处理协议回调方法 具体代码如下如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// @import CoreNFC 导入框架// 遵循 NFCNDEFReaderSessionDelegate 协议#import &quot;ViewController.h&quot;#include &lt;sys/types.h&gt;#include &lt;sys/sysctl.h&gt;@import CoreNFC;@interface ViewController ()&lt;NFCNDEFReaderSessionDelegate&gt;@end@implementation ViewController// 创建 NFCNDEFReaderSession 实例，开启NFCNDEFReaderSession// Tips：开启 // 条件：iphone7/7plus运行iOS11if ([ViewController isiPhone7oriPhone7Plus] &amp;&amp; [UIDevice currentDevice].systemVersion.floatValue &gt;= 11.0) &#123; // ReadingAvailable is YES if device supports NFC tag reading. if ([NFCNDEFReaderSession readingAvailable]) &#123; // beginScanning // invalidateAfterFirstRead 属性表示是否需要识别多个NFC标签，如果是YES，则会话会在第一次识别成功后终止。否则会话会持续 // 不过有一种例外情况，就是如果响应了-readerSession:didInvalidateWithError:方法，则是否为YES，会话都会被终止 NFCNDEFReaderSession *session = [[NFCNDEFReaderSession alloc] initWithDelegate:self queue:nil invalidateAfterFirstRead:YES]; [session beginSession]; &#125;&#125;// 处理协议回调方法#pragma mark - NFCReaderSessionDelegate// Check invalidation reason from the returned error. A new session instance is required to read new tags.// 识别出现Error后会话会自动终止，此时就需要程序重新开启会话- (void)readerSession:(NFCNDEFReaderSession *)session didInvalidateWithError:(NSError *)error &#123; // error明细参考NFCError.h NSLog(@&quot;%@&quot;,error);&#125;// Process detected NFCNDEFMessage objects- (void)readerSession:(NFCNDEFReaderSession *)session didDetectNDEFs:(NSArray&lt;NFCNDEFMessage *&gt; *)messages &#123; // 数组messages中是NFCNDEFMessage对象 // NFCNDEFMessage对象中有一个records数组，这个数组中是NFCNDEFPayload对象 // 参考NFCNDEFMessage、NFCNDEFPayload类 // 解析数据 for (NFCNDEFMessage *message in messages) &#123; for (NFCNDEFPayload *playLoad in message.records) &#123; NSLog(@&quot;typeNameFormat : %d&quot;, playLoad.typeNameFormat); NSLog(@&quot;type : %@&quot;, playLoad.type); NSLog(@&quot;identifier : %@&quot;, playLoad.identifier); NSLog(@&quot;playload : %@&quot;, playLoad.payload); &#125; &#125;&#125;// 主动终止会话，调用如下方法即可。[session invalidateSession]; 运行效果图 由于身边的NFC卡片都未识别成功，所以图二识别完成后的截图为WWDC视频中的截图。通过测试，目前用iphone7plus+iOS11测试读取上海交通卡、公司门禁卡，都没有读取成功，代码逻辑应该没有问题。可能是这些NFC芯片数据格式问题？不太确定是什么原因。不过貌似网上有人说是iOS11的问题，可以等iOS11正式版发布后再试试看，我也会持续关注。如果大家有相关的答案也可以告知我。谢谢。资料 https://github.com/EchoZuo/iOSCoreNFChttps://developer.apple.com/documentation/corenfc#overviewhttps://developer.apple.com/videos/play/wwdc2017/718/https://stackoverflow.com/questions/44380305/ios-11-core-nfc-any-sample-code Info Github: https://github.com/EchoZuo jianshu: https://www.jianshu.com/u/3390ce71084e CSDN: https://blog.csdn.net/zuoqianheng Email: zuoqianheng@foxmail.com Telegram: @echozuo]]></content>
      <categories>
        <category>iOS Dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CoreNFC</tag>
        <tag>NFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端常用命令集合]]></title>
    <url>%2F2017%2F04%2F25%2FMac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Mac 终端常用命令集合 pwd ：显示当前路径 cd dst_dir ：跳转到不同路径下，可以用相对路径，也可以用绝对路径 cd.. ：跳转到上级路径 cd../.. ：跳转到上上级路径 cd ：跳转到当前用户的家目录 cd ~ ：跳转到用户的家目录 ls ：列出当前路径下所有文件和文件夹 ls -l ：列出当前路径下所有文件和文件夹的详细信息 ls -a ：列出当前路径下的所有文件和文件夹，包括隐藏文件和隐藏文件夹，以及.和.. ls -lh ：将文件的大小已k、m、g这样的大小单位来显示 ls -lh后的信息说明 ：d开头的是文件夹，l开头的是链接文件，即文件的符号链接；其他文件都是-；rwx：可读可写可执行；rw-r--r--：rw是创建者权限，r是同一个组的用户的权限，最后的r是普通用户的权限。 touch file_name ：在当前路径下新建一个文件，这个文件的文件名就是file_name touch /Users/echozuo/test/new_file ：表示用绝对路径和文件名在其他路径下新建文件 touch file1 file2 file3 ：新建多个文件 mkdir new_dir ：在当前路径下新建一个文件夹new_dir mkdir /Users/echozuo/test/new_dir ：用绝对路径新建一个文件夹 mkdir ../test/new_dir ：用相对路径新建文件夹 mkdir dir1 dir2 dir3 ：新建多个文件夹 rm file_name ：删除一个文件 rm file1 file2 file3 ：删除多个文件 rm -r dir1 ：删除一个文件夹 rm -r dir1 dir2 dir3 ：删除多个文件夹 cp src_file new_dir ：将源文件（src_file）复制一份放到其他的文件夹（new_dir）下边 cp src_file new_dir/newname ：将源文件（src_file）复制一份放到其他的文件夹（new_dir）下边，并重新命名文件名为newname mv src_file new_dir ：将源文件剪切到其他文件夹下边 mv scr_file new_dir/newname ：将源文件剪切到其他文件夹下边并重新命名文件 man 命令名 ：表示查看这个命令的手册，例如： man cd man mkdir man touch ifconfig ：查看各个网卡的状态 ping ip ：看从本机到这个ip的网络通不通 route ip ：看从本机到这个ip的路由节点有哪些 VIM常用命令vim 是一个终端下的文本编译器。vim操作分为一般命令模式和编辑模式。 vim file_name ：会进入到一般命令模式下。如果路径下没有该文件，则会自动创建，但是在退出一般命令模式的时候，需要保存，否则首次创建的文件不会自动保存。 一般命令模式下能进行的操作有（常用操作）： i或者a或者o ：可以进入编辑模式 :w ：保存编辑后的文件内容 :q ：退出vim :wq ：保存并退出 :q! ：不保存并退出 :w! ：强制保存 h、j、k、l ：分别代表光标向左、向下、向上、向右移动 dd ：删除光标所在行 ndd ：删除光标所在行开始的n行。例如4dd表示删除光标所在行开始的4行 u ：撤回上一步的行为（操作） yy ：复制光标所在的行 yy n ：赋值光标所在行开始的n行 p ：粘贴在光标所在行的下一行位置 v ：进入可视模式，进入可视模式后可以用hjkl来移动光标选中文字 :set nu ：设置显示行号，同:set number :set nonu ：设置取消显示行号，同:set nonumber :n ：将光标定位在第几行 control + f ：往下翻页 control + b ：往上翻页 gg ：光标回调文件顶部 shift + g ：光标回调文件末行 /string ：表示在当前文件里从头部开始查找string ?string ：表示在当前文件里从尾部查找string shift + 4 ：将光标定位所在行的末尾 shift + i ：将光标定位在所在行的行首 编辑模式下可以进行的操作有： 可以编辑文件 按ESC退回到一般命令模式 补充终端命令 tar -cvf pakage.tar file1 file2 file3 ：表示将file1，file2，file3这三个文件打成一个压缩包pakage.tar tar -cvf pakage.tar dir ：表示将目录dir及该目录下的所有文件和文件打成一个包 tar -xcf pakage.tar ：将压缩包pakage.tar解压到当路径下]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
        <tag>终端</tag>
        <tag>命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
